{"version":3,"sources":["../../../../../app/view/vendor/path-to-regexp/index.js"],"names":["isArray","Array","arr","Object","prototype","toString","call","PATH_REGEXP","RegExp","join","escapeGroup","group","replace","attachKeys","re","keys","flags","options","sensitive","regexpToRegexp","path","groups","source","match","i","length","push","name","delimiter","optional","repeat","arrayToRegexp","parts","pathToRegexp","regexp","replacePath","index","_","escaped","prefix","key","capture","suffix","escape","strict","end","route","endsWithSlash","charAt","slice"],"mappings":"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","file":"index.js","sourcesContent":["var isArray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n/**\n * Expose `pathToRegexp`.\n */\n// module.exports = pathToRegexp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\n  // \"/route(\\\\d+)\" => [undefined, undefined, undefined, \"\\d+\", undefined]\n  '([\\\\/.])?(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^)])*)\\\\))?|\\\\(((?:\\\\\\\\.|[^)])*)\\\\))([+*?])?',\n  // Match regexp special characters that are always escaped.\n  '([.+*?=^!:${}()[\\\\]|\\\\/])'\n].join('|'), 'g');\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re;\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i';\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name:      i,\n        delimiter: null,\n        optional:  false,\n        repeat:    false\n      });\n    }\n  }\n\n  return attachKeys(path, keys);\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n  return attachKeys(regexp, keys);\n}\n\n/**\n * Replace the specific tags with regexp strings.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @return {String}\n */\nfunction replacePath (path, keys) {\n  var index = 0;\n\n  function replace (_, escaped, prefix, key, capture, group, suffix, escape) {\n    if (escaped) {\n      return escaped;\n    }\n\n    if (escape) {\n      return '\\\\' + escape;\n    }\n\n    var repeat   = suffix === '+' || suffix === '*';\n    var optional = suffix === '?' || suffix === '*';\n\n    keys.push({\n      name:      key || index++,\n      delimiter: prefix || '/',\n      optional:  optional,\n      repeat:    repeat\n    });\n\n    prefix = prefix ? ('\\\\' + prefix) : '';\n    capture = escapeGroup(capture || group || '[^' + (prefix || '\\\\/') + ']+?');\n\n    if (repeat) {\n      capture = capture + '(?:' + prefix + capture + ')*';\n    }\n\n    if (optional) {\n      return '(?:' + prefix + '(' + capture + '))?';\n    }\n\n    // Basic parameter support.\n    return prefix + '(' + capture + ')';\n  }\n\n  return path.replace(PATH_REGEXP, replace);\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || [];\n\n  if (!isArray(keys)) {\n    options = keys;\n    keys = [];\n  } else if (!options) {\n    options = {};\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options);\n  }\n\n  if (isArray(path)) {\n    return arrayToRegexp(path, keys, options);\n  }\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = replacePath(path, keys);\n  var endsWithSlash = path.charAt(path.length - 1) === '/';\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys);\n}\n"]}